"""TrackNet sequence-level dataset.

Provides fixed-length temporal windows from each clip using a sliding window
with configurable length and stride. Each time step contains an image, a
coordinate, and a visibility flag. Heatmaps are generated by collate utils.
"""

from __future__ import annotations

import csv
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Sequence, Tuple

from tracknet.datasets.base.sequence_dataset import BaseSequenceDataset
from tracknet.datasets.base.image_dataset import PreprocessConfig


@dataclass
class TrackNetSequenceDatasetConfig:
    """Configuration for TrackNet sequence dataset.

    Attributes:
        root: Root directory of TrackNet data (e.g., ``data/tracknet``).
        games: Iterable of game directory names to include.
        length: Window length ``T``.
        stride: Step between frames inside the window.
        preprocess: Preprocess/augmentation settings.
    """

    root: str
    games: Iterable[str]
    length: int
    stride: int
    preprocess: PreprocessConfig | None = None


class TrackNetSequenceDataset(BaseSequenceDataset):
    """Sequence dataset of sliding windows of frames from TrackNet."""

    def __init__(self, cfg: TrackNetSequenceDatasetConfig) -> None:
        super().__init__(length=cfg.length, stride=cfg.stride, preprocess=cfg.preprocess)
        self.root = Path(cfg.root)
        self.games = list(cfg.games)
        # Each window is a list of records (dicts with path/coord/visibility)
        self.windows: List[List[Dict[str, Any]]] = []
        self._build_windows()

    # ----- Indexing -----
    def _iter_clip_frames(self, clip_dir: Path) -> List[Dict[str, Any]]:
        label_csv = clip_dir / "Label.csv"
        if not label_csv.exists():
            return []
        def _safe_float(v: str | float | int, default: float = 0.0) -> float:
            try:
                s = str(v).strip()
                if s == "" or s.lower() == "nan":
                    return float(default)
                return float(s)
            except Exception:
                return float(default)

        labels: Dict[str, Tuple[int, float, float]] = {}
        with open(label_csv, "r", newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                fname = row["file name"].strip()
                vis = int(row.get("visibility", 1))
                x = _safe_float(row.get("x-coordinate", 0.0))
                y = _safe_float(row.get("y-coordinate", 0.0))
                labels[fname] = (vis, x, y)

        frames: List[Dict[str, Any]] = []
        for img_path in sorted(p for p in clip_dir.iterdir() if p.suffix.lower() == ".jpg"):
            key = img_path.name
            if key not in labels:
                continue
            vis, x, y = labels[key]
            frames.append({
                "path": str(img_path),
                "coord": (x, y),
                "visibility": vis,
                "clip": clip_dir.name,
            })
        return frames

    def _build_windows(self) -> None:
        T, S = self.length, self.stride
        for game in self.games:
            game_dir = self.root / game
            if not game_dir.exists():
                continue
            for clip_dir in sorted(p for p in game_dir.iterdir() if p.is_dir() and p.name.startswith("Clip")):
                frames = self._iter_clip_frames(clip_dir)
                n = len(frames)
                if n == 0:
                    continue
                # Sliding window [i, i+(T-1)*S]
                max_start = n - (T - 1) * S
                for i in range(0, max_start):
                    window: List[Dict[str, Any]] = []
                    ok = True
                    for k in range(T):
                        idx = i + k * S
                        if idx >= n:
                            ok = False
                            break
                        window.append(frames[idx])
                    if ok:
                        self.windows.append(window)

    # ----- Base hooks -----
    def _get_window_records(self, index: int) -> Sequence[Dict[str, Any]]:
        return self.windows[index]

    def __len__(self) -> int:
        return len(self.windows)
